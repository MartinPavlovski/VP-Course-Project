Семинарска работа по Визуелно програмирање - Smart Maze
============


1. Опис на проблем:
============
Се работи за игра која вклучува постигнување на одредени цели со цел да се помине играта успешно. Целите на играта се всушност нивоа така што како што преоѓаме на погорно ниво тежината на играта и одреди препреки се зголемуваат. Да се помине целата игра успешно подразбира да се поминат сите претходно опишани нивоа. 

Играта се состои всушност од проблем на решавање на класичен лавиринт само со неколку додатоци.
Опис на класичен лавиринт:
http://en.wikipedia.org/wiki/Maze


2. Интерфејс, функционалности и правила:
============
При вклучување на апликацијата се појавува почетниот прозорец во кои од вас се бара да внесете имe(nick) под кое ќе ја изминувате играта. Под полето за внес на име се наоѓа контрола за избор на ниво(тежина на лавиринтот кој ќе го решавате) бидејќи играта ви овозможува и покрај тоа кога прв пат ќе ја вклучите и не сте го поминале ни првото ниво, вие сепак можете директно да скокнете на погорните нивоа со цел да видите колкава е отприлика и нивната тежина.

По избор на ниво(тежина) преоѓате во режим на играње на соодветното ниво кое сте го избрале со клик на копчето “Започни”.

-  Во овој стадиум почнуваме со играта. Позадинскиот алгоритам го генерира лавиринт со 
   соодветната тежина за избраното ниво. Почнуваме од одредена случајно избрана почетна 
   позицина(замокот) и обозможено ни е користејќи ги копчињата ←↑→↓ од тастатурата во 
   зависност од тоа тоа дали сакаме да се придвижиме лево, горе, десно или доле соодветно. Наша 
   задача е со помош на овие копчина придвижувајќи се да стигнеме од почетната 
   позиција(замокот) до крајната позиција(вратата).

- При наоѓањето на нашиот пат до вратата постојат неколки начини на кои е можно да загубиме во играта:
  - Истек на времето зададено за соодветното ниво.
  - Постигнување на максималниот број на грешки кои може да бидат направени на тоа ниво 
     (грешка во играта се постигнува во оној момент кога пробуваме да се вратиме назад т.е. да 
      одиме во спротивна насока)
Пр: Сме тргнале десно и потоа сфаќаме дека сме го погрешиле патот и се придвижиме лево за да се вратиме наназад (за ваквта постапка се добива 1 негативен поен, понатаму не се добиваат дополнителни негативни поени за истата насока освен ако не сакаме пак да тргнеме десно што значи дека повторно сме се премислиле за насоката)

Тековното време и негативни поени можете да ги гледате од десната страна на прозорецот или пак визуелно да ја следите нивната промена преку двата Progress Bar-ови кое се поставени на дното на прозорецот.

-  Дополнително уште две опции се овозможени(контролите за нив се наоѓаат на десната страна 
   на прозорецот):
   - Restart (Нивото започнува одново, времето и негативните поени се ресетираат и се генерира   
     нов  random лавиринт со истата тежина соодветна за нивото(значи нема повторно да го имате  
     стариот лавиринт од моментот пред да стиснете на Restart, ова е со цел да не се паѓаат истите    
     нивоа кои би ги научиле по извесно време и секогаш би можеле да ја поминеме играта)
   - Give up (Со активирањето на оваа контрола значи дека се откажувате од тековната игра и 
     поради тоа компјутерот за вас го решава лавиринтот и ви го прикажува решението кое вие сте 
     требале да го изведете)


3. Програмско решение да проблемот:
============
Решението на овој проблем имплементирано на овој начин ги содржи следниве помошни класи за чување на податоците:
- Ball (класа во која се чуваат податоците за координатите, бојата и димензиите, насоката и 
   слично на топчето со кое движиме низ лавиринтот)
- EdgeHelpClass (помошна класа во која чува податоци за индексот на почетниот и крајниот јазел 
   на едно ребро во графот)
- EdgeList (класа во која чуваме листа од повеќе ребра во графот со кои сакаме да ја наполниме)
- Graph (податочната структура граф имплементирана со помош на листа на соседи во соодветна 
   класа)
- Koordinata (класа во која се чува инфомација за i и j компонентите на една координата (i,j)
- Labyrinth (клава во која е имплементиран позадинскиот алгоритам за генерирање и решавање 
    на лавиринтот доколку се откажеме)
+ Двете класи на формите StartForm и Form1 со нивните Event Handler-и.





Опис на функцијата  NewGame() која е во рамки на класта за формата Form1:
============

- Го иницијализираме објектот graphics.
- Ги изминуваме сите редици на матрицата од знаци LabyrinthWorld.
- За моменталната редица ги изминуваме елементите на сите колони кои се дел од таа редица.
- Ако знакот на моменталната редица и колона е знакот, тогаш...
- Креираме нов објект од класата Ball кој ќе исцрта топка со поченки координати (j* Kocka, i * Kocka)[обратно се бидејќи редиците кај матрицата се означени со i, а тоа е всушност ј координатата на конструкторот на топката која треба да се исцрта, исто така и за колоните] и со радиус Kocka која претходно во контрукторот ја иницијализираме на дебелината_или_должината_на_формата/бројот_на_елементите_во_едna_редица_или_колона.
- Nа X координатата од која треба да почне да се движи топката ball и ја доделуваме вредноста на редицата во која е најден знакот 'S'(start).
- Nа Y координатата од која треба да почне да се движи топката ball и ја доделуваме вредноста на колоната во која е најден знакот 'S'(start).
- Ја исцртуваме топката ball со помошна на објектот graphics наменет за цртање.
- Ако знакот на моменталната редина и колона е знакот E, тогаш..
- Nа променливата end_i која ја претставува X координатата на крајната точка до која треба да стигне топката ball во лавиринтот и ја доделуваме вредноста на редицата во која е најден знакот 'E'(end).
- Nа променливата end_j која ја претставува Y координатата на крајната точка до која треба да стигне топката ball во лавиринтот и ја доделуваме вредноста на колоната во која е најден знакот 'E'(end).
- Го повикуваме методот Invalidate() со цел да поттикнеме повикување на методот Paint на PictureBox-от во кој се исвртува лавиринтот
- Креираме објект timer од класата Timer.
- Креираме EventHandler која ќе се повикува на секое отчукување на тајмерот timer на одреден временски интервал.
- Како временски интервал на отчукување на тајмерот timer ја доделуваме вредноста на класната променлива TIMER_INTERVAL(1000ms или 1 секунда).
- Го повикуваме методот Start() на тајмерот timer со цел тој да почне со отчулување на времето при стартот на новата игра.


Опис на методите во класата Labyrinth:
============
- public static int abs(int a)
  - Метод за наоѓање на апсолутна вредност на еден цел број бидејќи оваа функција понатаму ќе има потреба да ја користиме.

- public static string kodirajKoordinati(int i, int j)
  - Метод за прикажување на координатите во соодветен формат.

- public static char[][] generirajLavirint(int N)
  - Метод која враќа random изгенериран лавиринт кој воедно е и решлив иако е random во форма на матрица од знаци во која ако има ѕид во лавиринтот на соодветното поле во матрицата има знак ‘#’, ако нема тогаш знакот е ‘ ‘, ако се работи за почетната точка има знак ‘S’ и ако се работи за крајната точка на лавиринтот во полето има знак ‘E’.

- public static char[][] oznaciPatekaVoLavirint_DFS(Stack<int> s, char[][] lavirint)
  - Метод кој враќа матрица од знаци во која веќе е најден патот со помош на Depth First Search означена на одредени полиња  за да се прикаже целосната патека од ‘S’ до ‘E’.

- public static char[][] oznaciPatekaVoLavirint_BFS(int[] prethodnik, char[][] lavirint)
  - Метод кој враќа матрица од знаци во која веќе е најден патот со помош на Breadth First Search означена на одредени полиња  за да се прикаже целосната патека од ‘S’ до ‘E’.

- public static Graph generirajGraph(char[][] lavirint)
  - Метод кој од матрицата која ја прима на влез гради граф со тоа што секое поле од матрица го прествуваме како јазел од графот, а неготе ребра пак ги додаваме според следниве правила:
    -  Доколку нема препрека помеѓу две полиња, тогаш додаваме ребро помеѓу нивните соодветни јазли во графот
    -	Доколку нема препрека помеѓу две полиња, тогаш не додаваме ребро помеѓу соодветните јазли во графот

- public static Stack<int> resiLavirint_DFS(char[][] lavirintMatrica)
  - Метод за решавање на лавиринтот со помош на DFS. Суштината е во тоа што графот ги претставува слободните полиња во лавиринтот, а тоа ни обезбедува избегнување на препреките. Методот воедно генерира граф од лавиринтот зададен со матрица и го решава со DFS, а на излез го враќа решението. Патеката на едноставен начин се реконструира со изминување на стекот во методот.

- public static int[] resiLavirint_BFS(char[][] lavirintMatrica)
  - Овој метод генерира граф од лавиринтот претставен со матрица и на излез враќа низа од претходно посетени јазли со BFS. Од оваа низа многу лесно се реконструира патеката со овој метод со помош на BFS. Бидејќи графот е нетежински, BFS гарантирано ќе го најде најкраткиот пат од ‘S’(start) до ‘E’(exit) по логика на број на изминати јазли.

- public static char[][] najdiPatekaVoRandomLavirint_DFS(char[][] lavirint)
  - Функција за едноставен повик и организација на методите дефинирани погоре меѓу кои е вклучен и повикот на методот resiLavirint_DFS(lavirint) и oznaciPatekaVoLavirint_DFS(patekaResenie, lavirint).

- public static void najdiPatekaVoRandomLavirint_BFS(char[][] lavirint)
  - Функција за едноставен повик и организација на методите дефинирани погоре меѓу кои е вклучен и повикот на методот resiLavirint_BFS(lavirint) и oznaciPatekaVoLavirint_BFS(prethodnik, lavirint).

- public static void resiRandomLavirint(int N)	
  - Метод за комплетно решавање на еден лавиринт со 2*N+1 x 2*N+1 димензии со помош на DFS и BFS.


4. Користена литература:
============
- Поттик и идеја за имплементација за алгоритмот за самостојно решавање на лавиринтот:
  http://en.wikipedia.org/wiki/Maze_solving_algorithm 


Изработил:
============
- Мартин Павловски
  Бр.Индекс: 115048
  Насока: Информатика и Компјутерско Инженерство
       
       


